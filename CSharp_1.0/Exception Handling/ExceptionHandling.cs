/**
Exception handling uses the try, catch, and finally keywords to try actions that may not succeed, to handle failures when you decide that it's reasonable to do so, and to clean up resources afterward. Exceptions can be generated by the common language runtime (CLR), by .NET or third-party libraries, or by application code. Exceptions are created by using the throw keyword.

In many cases, an exception may be thrown not by a method that your code has called directly, but by another method further down in the call stack. When an exception is thrown, the CLR will unwind the stack, looking for a method with a catch block for the specific exception type, and it will execute the first such catch block that it finds. If it finds no appropriate catch block anywhere in the call stack, it will terminate the process and display a message to the user.

Exceptions have the following properties:
    1.Exceptions are types that all ultimately derive from System.Exception.
    2.Use a try block around the statements that might throw exceptions.
    3.Once an exception occurs in the try block, the flow of control jumps to the first associated exception handler that is present anywhere in the call stack. In C#, the catch keyword is used to define an exception handler.
    4.If no exception handler for a given exception is present, the program stops executing with an error message.
    5.Don't catch an exception unless you can handle it and leave the application in a known state. If you catch System.Exception, rethrow it using the throw keyword at the end of the catch block.
    6.If a catch block defines an exception variable, you can use it to obtain more information about the type of exception that occurred.
    7.Exceptions can be explicitly generated by a program by using the throw keyword.
    8.Exception objects contain detailed information about the error, such as the state of the call stack and a text description of the error.
    9.Code in a finally block is executed regardless of if an exception is thrown. Use a finally block to release resources, for example to close any streams or files that were opened in the try block.
    10.Managed exceptions in .NET are implemented on top of the Win32 structured exception handling mechanism

Exceptions are represented by classes derived from Exception. This class identifies the type of exception and contains properties that have details about the exception. Throwing an exception involves creating an instance of an exception-derived class, optionally configuring properties of the exception, and then throwing the object by using the throw keyword.

After an exception is thrown, the runtime checks the current statement to see whether it is within a try block. If it is, any catch blocks associated with the try block are checked to see whether they can catch the exception. Catch blocks typically specify exception types; if the type of the catch block is the same type as the exception, or a base class of the exception, the catch block can handle the method

If the statement that throws an exception isn't within a try block or if the try block that encloses it has no matching catch block, the runtime checks the calling method for a try statement and catch blocks. The runtime continues up the calling stack, searching for a compatible catch block. After the catch block is found and executed, control is passed to the next statement after that catch block.

A try statement can contain more than one catch block. The first catch statement that can handle the exception is executed; any following catch statements, even if they're compatible, are ignored. Order catch blocks from most specific (or most-derived) to least specific.

Before the catch block is executed, the runtime checks for finally blocks. Finally blocks enable the programmer to clean up any ambiguous state that could be left over from an aborted try block, or to release any external resources (such as graphics handles, database connections, or file streams) without waiting for the garbage collector in the runtime to finalize the objects. 

If no compatible catch block is found on the call stack after an exception is thrown, one of three things occurs:
    If the exception is within a finalizer, the finalizer is aborted and the base finalizer, if any, is called.
    If the call stack contains a static constructor, or a static field initializer, a TypeInitializationException is thrown, with the original exception assigned to the InnerException property of the new exception.
    If the start of the thread is reached, the thread is terminated.

A try block without a catch or finally block causes a compiler error.

Catch exceptions when the following conditions are true:
    1.You have a good understanding of why the exception might be thrown, and you can implement a specific recovery, such as prompting the user to enter a new file name when you catch a FileNotFoundException object.
    2.You can create and throw a new, more specific exception.
    3.You want to partially handle an exception before passing it on for more handling.


Finally Blocks:
--------------
A finally block enables you to clean up actions that are performed in a try block. If present, the finally block executes last, after the try block and any matched catch block. A finally block always runs, whether an exception is thrown or a catch block matching the exception type is found.

The finally block can be used to release resources such as file streams, database connections, and graphics handles without waiting for the garbage collector in the runtime to finalize the objects.


Programmers should throw exceptions when one or more of the following conditions are true:
    1.The method can't complete its defined functionality. For example, if a parameter to a method has an invalid value:
    2.An inappropriate call to an object is made, based on the object state. One example might be trying to write to a read-only file. In cases where an object state doesn't allow an operation, throw an instance of InvalidOperationException or an object based on a derivation of this class.
    3.When an argument to a method causes an exception. In this case, the original exception should be caught and an ArgumentException instance should be created. The original exception should be passed to the constructor of the ArgumentException as the InnerException parameter:
        catch (IndexOutOfRangeException e)
        {
            throw new ArgumentOutOfRangeException(
                "Parameter index is out of range.", e);
        }

Exceptions contain a property named StackTrace. This string contains the name of the methods on the current call stack, together with the file name and line number where the exception was thrown for each method. A StackTrace object is created automatically by the common language runtime (CLR) from the point of the throw statement, so that exceptions must be thrown from the point where the stack trace should begin.

All exceptions contain a property named Message. This string should be set to explain the reason for the exception. Information that is sensitive to security shouldn't be put in the message text. In addition to Message, ArgumentException contains a property named ParamName that should be set to the name of the argument that caused the exception to be thrown. In a property setter, ParamName should be set to value.

Public and protected methods throw exceptions whenever they can't complete their intended functions. The exception class thrown is the most specific exception available that fits the error conditions. These exceptions should be documented as part of the class functionality, and derived classes or updates to the original class should retain the same behavior for backward compatibility.

Things to avoid when throwing exceptions:
-----------------------------------------
The following list identifies practices to avoid when throwing exceptions:
    1.Don't use exceptions to change the flow of a program as part of ordinary execution. Use exceptions to report and handle error conditions.
    2.Exceptions shouldn't be returned as a return value or parameter instead of being thrown.
    3.Don't throw System.Exception, System.SystemException, System.NullReferenceException, or System.IndexOutOfRangeException intentionally from your own source code.
    4.Don't create exceptions that can be thrown in debug mode but not release mode. To identify run-time errors during the development phase, use Debug Assert instead.

Exceptions in task-returning methods:
--------------------------------------
Methods declared with the async modifier have some special considerations when it comes to exceptions. Exceptions thrown in an async method are stored in the returned task and don't emerge until, for example, the task is awaited.

Define exception classes:
---------------------------
Programs can throw a predefined exception class in the System namespace (except where previously noted), or create their own exception classes by deriving from Exception. The derived classes should define at least three constructors: one parameterless constructor, one that sets the message property, and one that sets both the Message and InnerException properties.
Add new properties to the exception class when the data they provide is useful to resolving the exception. If new properties are added to the derived exception class, ToString() should be overridden to return the added information.

Compiler-generated exceptions:
-----------------------------
Some exceptions are thrown automatically by the .NET runtime when basic operations fail. These exceptions and their error conditions are listed in the following table.

Exception	Description
ArithmeticException	A base class for exceptions that occur during arithmetic operations, such as DivideByZeroException and OverflowException.
ArrayTypeMismatchException	Thrown when an array can't store a given element because the actual type of the element is incompatible with the actual type of the array.
DivideByZeroException	Thrown when an attempt is made to divide an integral value by zero.
IndexOutOfRangeException	Thrown when an attempt is made to index an array when the index is less than zero or outside the bounds of the array.
InvalidCastException	Thrown when an explicit conversion from a base type to an interface or to a derived type fails at run time.
NullReferenceException	Thrown when an attempt is made to reference an object whose value is null.
OutOfMemoryException	Thrown when an attempt to allocate memory using the new operator fails. This exception indicates that the memory available to the common language runtime has been exhausted.
OverflowException	Thrown when an arithmetic operation in a checked context overflows.
StackOverflowException	Thrown when the execution stack is exhausted by having too many pending method calls; usually indicates a very deep or infinite recursion.
TypeInitializationException	Thrown when a static constructor throws an exception and no compatible catch clause exists to catch it.
ArgumentException	Base class for all argument exceptions.	None (use a derived class of this exception).
ArgumentNullException	Thrown by methods that do not allow an argument to be null.	String s = null;
"Calculate".IndexOf(s);
ArgumentOutOfRangeException	Thrown by methods that verify that arguments are in a given range.

**/
using System;

namespace ExceptionHandling{
    class ExceptionHandlingClass{
        static double SafeDivision(double x, double y)
        {
            if (y == 0)
                throw new DivideByZeroException();
            return x / y;
        }

        public static int GetInt(int[] array, int index)
        {
            try
            {
                return array[index];
            }
            //You can also specify exception filters to add a boolean expression to a catch clause. Exception filters indicate that a specific catch clause matches only when that condition is true.
            catch (IndexOutOfRangeException e) when (index < 0) 
            {
                throw new ArgumentOutOfRangeException(
                    "Parameter index cannot be negative.", e);
            }
            catch (IndexOutOfRangeException e)
            {
                Console.WriteLine("IndexOutOfRangeException in GetInt Method.");
                //re - throw;
                throw;
                throw new ArgumentOutOfRangeException(
                    "Parameter index is out of range.", e);
            }
            finally{
                Console.WriteLine("GetInt Method : finally Block .");
            }
        }


        public static void Main(){
            Console.WriteLine("Exception Handling.");
            // Input for test purposes. Change the values to see
            // exception handling behavior.
            double a = 98, b = 0;
            double result;

            try
            {
                result = SafeDivision(a, b);
                Console.WriteLine($"{a} divided by {b} = {result}");
            }
            catch (DivideByZeroException)
            {
                Console.WriteLine("Attempted divide by zero.");
            }

            try{
                ExceptionHandlingClass.GetInt([1,2,3], 5);
            }
            catch(ArgumentOutOfRangeException ex){
                Console.WriteLine("ArgumentOutOfRangeException Main Method");
            }
            catch(Exception ex){
                Console.WriteLine("Main Method :"+ ex);
            }
        }
    }
}