using System;
/**
A method is a code block that contains a series of statements. A program causes the statements to be executed by calling the method and specifying any required method arguments. In C#, every executed instruction is performed in the context of a method.

The Main method is the entry point for every C# application and it's called by the common language runtime (CLR) when the program is started. In an application that uses top-level statements, the Main method is generated by the compiler and contains all top-level statements.

Method signatures
Methods are declared in a class, struct, or interface by specifying the access level such as public or private, optional modifiers such as abstract or sealed, the return value, the name of the method, and any method parameters. These parts together are the signature of the method.

A return type of a method is not part of the signature of the method for the purposes of method overloading. However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.

Method parameters are enclosed in parentheses and are separated by commas. Empty parentheses indicate that the method requires no parameters.

Method access: 
Calling a method on an object is like accessing a field. After the object name, add a period, the name of the method, and parentheses. Arguments are listed within the parentheses, and are separated by commas.

Method parameters vs. arguments:
The method definition specifies the names and types of any parameters that are required. When calling code calls the method, it provides concrete values called arguments for each parameter.
The arguments must be compatible with the parameter type but the argument name (if any) used in the calling code doesn't have to be the same as the parameter named defined in the method.

Passing by reference vs. passing by value
By default, when an instance of a value type is passed to a method, its copy is passed instead of the instance itself. Therefore, changes to the argument have no effect on the original instance in the calling method. To pass a value-type instance by reference, use the ref keyword. For more information, see Passing Value-Type Parameters.
When an object of a reference type is passed to a method, a reference to the object is passed. That is, the method receives not the object itself but an argument that indicates the location of the object. If you change a member of the object by using this reference, the change is reflected in the argument in the calling method, even if you pass the object by value.

Return values
Methods can return a value to the caller. If the return type (the type listed before the method name) is not void, the method can return the value by using the return statement. A statement with the return keyword followed by a value that matches the return type will return that value to the method caller.
The value can be returned to the caller by value or by reference. Values are returned to the caller by reference if the ref keyword is used in the method signature and it follows each return keyword.
The return keyword also stops the execution of the method. If the return type is void, a return statement without a value is still useful to stop the execution of the method. Without the return keyword, the method will stop executing when it reaches the end of the code block. Methods with a non-void return type are required to use the return keyword to return a value. 
To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient. You can also assign the return value to a variable.
To use a value returned by reference from a method, you must declare a ref local variable if you intend to modify its value.


Expression body definitions
It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method. There is a syntax shortcut for defining such methods using =>:




**/

namespace Methods{

    abstract class MotorCycle{
        // Anyone can call this.
        public void StartEngine() {/* Method statements here */ }

        // Only derived classes can call this.
        protected void AddGas(int gallons) { /* Method statements here */ }

        // Derived classes can override the base class implementation.
        public virtual int Drive(int miles, int speed) { /* Method statements here */ return 1; }


        // Derived classes must implement this.
        public abstract double GetTopSpeed();

    }

    class passByTest{
        public int age = 0;
        public int[] collections = new int[5];

        public void modify(int i){
            i = 10;
            Console.WriteLine("Modified :"+ i);
        }

        public void modifyReference(int[] list){
            list[0] = 10;
            Console.WriteLine("Modified :"+ list[0]);
        }

        public void modifierClass(passByTest obj){
            obj.age = 20;
            obj.collections[4] = 40;
        }
    }

    class Methods : MotorCycle {

        public ref double GetEstimatedDistance(ref double estDistance)
        {
            return ref estDistance;
        }

        public string First = "Nickil";

        public string Last = "S";

        public void Print() => Console.WriteLine(First + " " + Last);

        public void Caller()
        {
            int numA = 4;
            // Call with an int variable.
            int productA = Square(numA);

            int numB = 32;
            // Call with another int variable.
            int productB = Square(numB);

            // Call with an integer literal.
            int productC = Square(12);

            // Call with an expression that evaluates to int.
            productC = Square(productA * 3);
        }

        int Square(int i)
        {
            // Store input argument in a local variable.
            int input = i;
            return input * input;
        }

        public override double GetTopSpeed()
        {
            return 108.4;
        }

        public static void Main(){
            Console.WriteLine("Methods :");
            Methods moto = new Methods();

            moto.StartEngine();
            moto.AddGas(15);
            moto.Drive(5, 20);
            double speed = moto.GetTopSpeed();
            Console.WriteLine($"My top speed is {speed}");

            moto.Caller();

            moto.Print();

            //Pass by value
            int a = 5;
            passByTest p = new passByTest();
            p.age = 24;
            Console.WriteLine("Age is :"+ p.age);
            p.modify(a);
            p.collections[0] = 1;
            p.collections[1] = 2;
            Console.WriteLine($"Original a is :{a} and age is {p.age}, after modify : {p.age}");
            int[] b = [1,2,3,4,5];
            Console.WriteLine(b[0]+" before modify :"+ b[0]);
            p.modifyReference(b);
            Console.WriteLine(b[0]+" after modify :"+ b[0]);

            //Passing class object to modify
            Console.WriteLine(p.age+ " - age, collection at 4th index is :" + p.collections[4]);
            p.modifierClass(p);
            Console.WriteLine(p.age+ " - after modify age, collection at 4th index is :" + p.collections[4]);
        }
    }
}